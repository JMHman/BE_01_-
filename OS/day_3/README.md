## 1일차 과제
  1. CPU의 구성요소 ALU,CU 그리고 레지스터 각각의 역할을 간략하게 정리해보자
    * ALU - Arithmetic and Logical Unit 이라고 한다.
      연산 담당 파트로 덧셈뺄셈을 처리하는 산술연산과 and,or을 처리하는 논리 연산등을 수행해서 컴퓨터를 컴퓨터 답게 이용할수 있게 해준다

    * CU - Control Unit 이라고 한다
      명령어를 해석해서 ALU에게 보내준다. (0101)형식의 명령어를 해석해서 전해주기 때문에 통역사 같은 업무를 한다

    * Register Set - 레지스터 이다
      CPU 내부에 존제하는 작은 메모리이다. ALU가 명령어를 연산하고 있을때 새로 명령어가 전달되면 앞의 연산 작업이 완료될때 까지 레지스터에 보관된다.
      - 프로그램 카운터: pass
      - 인스트럭션 레지스터: pass
      - 어드레스 레지스터: pass
      - 버퍼 레지스터: pass
      - 플래그 레지스터: pass
      - 스택 포인터: pass
      - : 등등 이 있다.

  2. 메인 메모리와 보조 기억장치의 차이를 간략하게 서술해보자
    * 보조 기억장치는 HDD,SSD 같이 프로그램들이 다운받아지는 메모리 이고 메인 메모리는 프로그램이 실행되면 보조 기억장치에 있던 프로그램이 이동을 하는 곳으로 메인메모리에서 CPU로 보내지며 실행이 된다. 이때 실행되는 방식이 1에서 정리한 CPU 구성요소의 처리 방식으로 처리된다

  3. 버스 시스템은 데이더를 주고받기 위한 경로로, 데이터의 종류에 따라 세 가지로 구분할 수 있다. 세 가지는 무엇인지 말해보자
    - 데이터 버스: 데이터 이동을 위해 필요한 버스
    - 컨트롤 버스: CPU가 원하는 바를 메모리에 전달하기 위한 버스
    - 어드레스 버스: 주소값을 이동하기 위해 필요한 버스

## 2일차 과제
  08.py 가 과제의 답임

## 3일차 과제
  데드락, 즉 교착상대에 대해서 비유적으로 설명할 떄 주로 사용되는 예시로
  '식사하는 철학자 문제' 라는 것이 있다.

  여기에 대해 조사하고 정리하는 글을 써 보자.
  1. 개요 
    운영체제의 교착(데드락)상태를 설명하기 위한 문제. 1965년에 에츠허르 다익스트라가 만든 문제이다.

    식사하는 철학자 문제는 컴퓨터과학에서 동시성과 교착 상태를 설명하는 예시로, 여러 프로세스(또는 스레드)가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.
  2. 상세
    다섯 명의 철학자가 하나의 원탁에 앉아 식사를 한다. 각각의 철학자들 사이에는 포크가 하나씩 있고, 앞에는 접시가 있다. 접시 안에 든 요리는 포크를 두개 사용하여 먹어야만 하는 스파게티 이다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다. 따라서 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하고 있어야만 한다. 또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다. 이 때, 어떤 철학자도 굶지 않고 식사할 수 있도록 하는 방법은 무엇인가?
    - 문제 --- 각 철학자들이 다음의 연속된 과정을 통해 식사를 한다고 생각해 보자
      1. 일정 시간 생각을 한다.
      2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
      3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
      4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
      5. 오른쪽 포크를 내려놓는다.
      6. 왼쪽 포크를 내려놓는다.
      7. 다시 1번으로 돌아간다.
    왼쪽 포크와 오른쪽 포크를 한번에(atomic) 가져오는 것이 아니라 순서대로(sequentially) 가져오기 때문에, 모두가 왼쪽 포크부터 집어드는 이런 단순무식한 알고리즘을 가지고 있으면 문제가 생길 수밖에 없다. 5명의 철학자 전부 왼쪽 포크를 들고 있다면 오른쪽 포크를 얻으려고 할때 오른쪽 포크는 이미 상대방이 가져간 상태이고, 오른쪽 철학자의 오른쪽 역시 가져간 상태이고.. 이렇게 원탁을 한 바퀴 돌아 자기 자신까지 돌아오면 모든 철학자들이 3번 상태에 머무르며 자기 오른쪽 포크가 사용 가능해질 때까지 영원히 기다리고만 있는 교착(Deadlock) 상태에 빠지게 된다.

    또한 어떤 경우에는 계속해서 양쪽 포크를 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

  3. 해결법
    * OS 차원의 해결법
      - 한 철학자가 한 포크를 잡는 순간, 반대쪽 포크를 잡을 때까지 포크의 사용권리를 남에게 넘길 수 없도록 하는 것이다. 현실 세계에서는 CPU의 인터럽트를 무시하는 방식[5]으로 구현할 수 있다. 하지만 이는 커널 레벨에서만 가능한 방식으로, 사용자에게 인터럽트 제어권을 넘겨준다면 악의적으로 사용해 혼자 CPU를 처묵처묵하는 상황이 발생할 수 있다.

      단, 멀티쓰레드 환경이라면 사용자 레벨에서 구현할 수 있는 방식이 있다. 사용자가 Semaphore나 Mutex lock등을 이용해 Critical Section(공유 자원에 Write를 수행하는 경우 등)에서 자신이 만든 다른 쓰레드가 CPU를 잡지 못하게 만들어 쓰레드간의 교착 상태를 방지할 수 있다.
    * 하드웨어 아키텍처 차원의 해결법
      - CPU에서 관련 명령어를 제공할 경우, 이것을 이용할 수도 있다. 양쪽 포크를 동시에 잡게 하는 명령어를 사용하면 두 철학자가 동시에 하나의 포크만 잡는 상황은 벌어지지 않는다. 이런 명령어는 쪼갤 수 없는 명령어라는 의미로 Atomic Instruction이라고도 한다.
    * 소프트웨어 차원의 해결법
      - 타임아웃 설정. 철학자가 포크를 집고 간발의 차이로 다른 쪽 포크를 획득하는데 실패(…)한다면, 당장 식사 시도를 포기하고 잡았던 포크를 반납하게 한다. 가장 간단하고 가장 강제적이지만, 교착이 발생하였을 때 해당 타임아웃 시간이 될 때까지 일부러 기다려줘야 한다는 딜레이가 있다.
      - 철학자들 중 하나는 포크를 오른쪽부터 잡게 한다고 생각해 보자. 예를 들어 1번 철학자는 왼쪽부터, 2번 철학자는 오른쪽부터 잡는다. 1번 철학자가 왼쪽 포크만 잡은 상태에서 행동권이 2번 철학자에게 넘어간다고 하더라도, 2번 철학자는 자신의 오른쪽 포크가 현재 사용 불가능하기 때문에, 첫번째 포크를 잡으려는 상황에서 멈춰 있게 된다. 이 상황에서 1번 철학자로 다시 행동권이 넘어오게 되면 1번 철학자는 자신의 오른쪽 포크를 잡고 다시 식사를 할 수 있게 된다.
      - 포크 하나하나에 비교 가능한 고유 값을 부여하여, 고유 값이 높은(또는 낮은) 순서대로 포크를 집게 만든다. 고유 값은 보통 해시를 사용하는 게 일반적이며, 서로 겹치면 안 된다.
      예를 들어, 포크 다섯 개의 고유번호가 각각 순서대로 295, 329, 683, 591, 274이고 고유번호가 높은 순서대로 포크를 집는다고 가정하자, 3번 철학자는 3번과 4번 포크를 사용할 텐데, 그 포크들의 값은 683, 591이므로 3번 철학자는 683의 값을 가진 3번 포크를 먼저 집는다. 반대로 1번 철학자는 1번과 2번 포크를 사용할 텐데, 그 포크들의 값은 295, 329이므로 1번 철학자는 329의 값을 가진 2번 포크를 먼저 집는다. 이렇게 하면 절대로 모든 철학자가 하나의 포크를 집고 대기하는 일이 없으므로(a > b > c > d > e > a, 또는 반대일 수는 없으므로) 문제를 해결할 수 있다.

## 3일차 과제 - 각색 버전(젓가락 문화권을 위한 각색)
  1. 한 원형 테이블에는 N명의 철학자가 앉아있습니다.
  2. 각 철학자는 젓가락을 왼쪽과 오른쪽에 하나씩 가지고 있습니다.
  3. 철학자는 생각을 하다가 배가 고프면 식사를 합니다. 식사를 하려면 왼쪽과 오른쪽의 젓가락을 모두 들어야 합니다.
  4. 철학자가 왼쪽의 젓가락을 들면 오른쪽의 젓가락을 들기 위해서는 다른 철학자가 사용하지 않고 있어야 합니다.
  5. 마찬가지로 철학자가 오른쪽의 젓가락을 들면 왼쪽의 젓가락을 들기 위해서는 다른 철학자가 사용하지 않고 있어야 합니다.
  6. 한 철학자가 두 개의 젓가락을 모두 들고 있을 때만 식사를 시작할 수 있습니다.
  
  * 발생하는 문제를
  1. 데드락(Deadlock): 각 철학자가 젓가락을 한 번에 하나씩만 집을 수 있기 때문에 서로 대기하면서 아무도 식사를 시작하지 못하고 무한정 대기하는 상황이 발생할 수 있습니다.
  2. 교착상태(Starvation): 특정 철학자가 젓가락을 얻지 못하는 상황이 계속해서 발생하여 영원히 식사를 할 수 없는 상태가 되는 경우도 있을 수 있습니다.

  * 해결 방법
    - 이러한 문제를 해결하기 위해서는 적절한 동기화 메커니즘이나 규칙을 도입하여 데드락이나 교착상태를 방지할 수 있어야 합니다. 예를 들어, 두 개의 젓가락을 동시에 집을 수 있을 때만 식사를 시작하도록 하거나, 한 명의 철학자만이 식사를 하도록 제한하는 등의 방법이 있습니다.
